"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/socket.io-adapter";
exports.ids = ["vendor-chunks/socket.io-adapter"];
exports.modules = {

/***/ "(rsc)/./node_modules/socket.io-adapter/dist/cluster-adapter.js":
/*!****************************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/cluster-adapter.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ClusterAdapterWithHeartbeat = exports.ClusterAdapter = exports.MessageType = void 0;\nconst in_memory_adapter_1 = __webpack_require__(/*! ./in-memory-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/in-memory-adapter.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst debug = (0, debug_1.debug)(\"socket.io-adapter\");\nconst EMITTER_UID = \"emitter\";\nconst DEFAULT_TIMEOUT = 5000;\nfunction randomId() {\n    return (0, crypto_1.randomBytes)(8).toString(\"hex\");\n}\nvar MessageType;\n(function (MessageType) {\n    MessageType[MessageType[\"INITIAL_HEARTBEAT\"] = 1] = \"INITIAL_HEARTBEAT\";\n    MessageType[MessageType[\"HEARTBEAT\"] = 2] = \"HEARTBEAT\";\n    MessageType[MessageType[\"BROADCAST\"] = 3] = \"BROADCAST\";\n    MessageType[MessageType[\"SOCKETS_JOIN\"] = 4] = \"SOCKETS_JOIN\";\n    MessageType[MessageType[\"SOCKETS_LEAVE\"] = 5] = \"SOCKETS_LEAVE\";\n    MessageType[MessageType[\"DISCONNECT_SOCKETS\"] = 6] = \"DISCONNECT_SOCKETS\";\n    MessageType[MessageType[\"FETCH_SOCKETS\"] = 7] = \"FETCH_SOCKETS\";\n    MessageType[MessageType[\"FETCH_SOCKETS_RESPONSE\"] = 8] = \"FETCH_SOCKETS_RESPONSE\";\n    MessageType[MessageType[\"SERVER_SIDE_EMIT\"] = 9] = \"SERVER_SIDE_EMIT\";\n    MessageType[MessageType[\"SERVER_SIDE_EMIT_RESPONSE\"] = 10] = \"SERVER_SIDE_EMIT_RESPONSE\";\n    MessageType[MessageType[\"BROADCAST_CLIENT_COUNT\"] = 11] = \"BROADCAST_CLIENT_COUNT\";\n    MessageType[MessageType[\"BROADCAST_ACK\"] = 12] = \"BROADCAST_ACK\";\n    MessageType[MessageType[\"ADAPTER_CLOSE\"] = 13] = \"ADAPTER_CLOSE\";\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\nfunction encodeOptions(opts) {\n    return {\n        rooms: [...opts.rooms],\n        except: [...opts.except],\n        flags: opts.flags,\n    };\n}\nfunction decodeOptions(opts) {\n    return {\n        rooms: new Set(opts.rooms),\n        except: new Set(opts.except),\n        flags: opts.flags,\n    };\n}\n/**\n * A cluster-ready adapter. Any extending class must:\n *\n * - implement {@link ClusterAdapter#doPublish} and {@link ClusterAdapter#doPublishResponse}\n * - call {@link ClusterAdapter#onMessage} and {@link ClusterAdapter#onResponse}\n */\nclass ClusterAdapter extends in_memory_adapter_1.Adapter {\n    constructor(nsp) {\n        super(nsp);\n        this.requests = new Map();\n        this.ackRequests = new Map();\n        this.uid = randomId();\n    }\n    /**\n     * Called when receiving a message from another member of the cluster.\n     *\n     * @param message\n     * @param offset\n     * @protected\n     */\n    onMessage(message, offset) {\n        if (message.uid === this.uid) {\n            return debug(\"[%s] ignore message from self\", this.uid);\n        }\n        debug(\"[%s] new event of type %d from %s\", this.uid, message.type, message.uid);\n        switch (message.type) {\n            case MessageType.BROADCAST: {\n                const withAck = message.data.requestId !== undefined;\n                if (withAck) {\n                    super.broadcastWithAck(message.data.packet, decodeOptions(message.data.opts), (clientCount) => {\n                        debug(\"[%s] waiting for %d client acknowledgements\", this.uid, clientCount);\n                        this.publishResponse(message.uid, {\n                            type: MessageType.BROADCAST_CLIENT_COUNT,\n                            data: {\n                                requestId: message.data.requestId,\n                                clientCount,\n                            },\n                        });\n                    }, (arg) => {\n                        debug(\"[%s] received acknowledgement with value %j\", this.uid, arg);\n                        this.publishResponse(message.uid, {\n                            type: MessageType.BROADCAST_ACK,\n                            data: {\n                                requestId: message.data.requestId,\n                                packet: arg,\n                            },\n                        });\n                    });\n                }\n                else {\n                    const packet = message.data.packet;\n                    const opts = decodeOptions(message.data.opts);\n                    this.addOffsetIfNecessary(packet, opts, offset);\n                    super.broadcast(packet, opts);\n                }\n                break;\n            }\n            case MessageType.SOCKETS_JOIN:\n                super.addSockets(decodeOptions(message.data.opts), message.data.rooms);\n                break;\n            case MessageType.SOCKETS_LEAVE:\n                super.delSockets(decodeOptions(message.data.opts), message.data.rooms);\n                break;\n            case MessageType.DISCONNECT_SOCKETS:\n                super.disconnectSockets(decodeOptions(message.data.opts), message.data.close);\n                break;\n            case MessageType.FETCH_SOCKETS: {\n                debug(\"[%s] calling fetchSockets with opts %j\", this.uid, message.data.opts);\n                super\n                    .fetchSockets(decodeOptions(message.data.opts))\n                    .then((localSockets) => {\n                    this.publishResponse(message.uid, {\n                        type: MessageType.FETCH_SOCKETS_RESPONSE,\n                        data: {\n                            requestId: message.data.requestId,\n                            sockets: localSockets.map((socket) => {\n                                // remove sessionStore from handshake, as it may contain circular references\n                                const _a = socket.handshake, { sessionStore } = _a, handshake = __rest(_a, [\"sessionStore\"]);\n                                return {\n                                    id: socket.id,\n                                    handshake,\n                                    rooms: [...socket.rooms],\n                                    data: socket.data,\n                                };\n                            }),\n                        },\n                    });\n                });\n                break;\n            }\n            case MessageType.SERVER_SIDE_EMIT: {\n                const packet = message.data.packet;\n                const withAck = message.data.requestId !== undefined;\n                if (!withAck) {\n                    this.nsp._onServerSideEmit(packet);\n                    return;\n                }\n                let called = false;\n                const callback = (arg) => {\n                    // only one argument is expected\n                    if (called) {\n                        return;\n                    }\n                    called = true;\n                    debug(\"[%s] calling acknowledgement with %j\", this.uid, arg);\n                    this.publishResponse(message.uid, {\n                        type: MessageType.SERVER_SIDE_EMIT_RESPONSE,\n                        data: {\n                            requestId: message.data.requestId,\n                            packet: arg,\n                        },\n                    });\n                };\n                this.nsp._onServerSideEmit([...packet, callback]);\n                break;\n            }\n            // @ts-ignore\n            case MessageType.BROADCAST_CLIENT_COUNT:\n            // @ts-ignore\n            case MessageType.BROADCAST_ACK:\n            // @ts-ignore\n            case MessageType.FETCH_SOCKETS_RESPONSE:\n            // @ts-ignore\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE:\n                // extending classes may not make a distinction between a ClusterMessage and a ClusterResponse payload and may\n                // always call the onMessage() method\n                this.onResponse(message);\n                break;\n            default:\n                debug(\"[%s] unknown message type: %s\", this.uid, message.type);\n        }\n    }\n    /**\n     * Called when receiving a response from another member of the cluster.\n     *\n     * @param response\n     * @protected\n     */\n    onResponse(response) {\n        var _a, _b;\n        const requestId = response.data.requestId;\n        debug(\"[%s] received response %s to request %s\", this.uid, response.type, requestId);\n        switch (response.type) {\n            case MessageType.BROADCAST_CLIENT_COUNT: {\n                (_a = this.ackRequests\n                    .get(requestId)) === null || _a === void 0 ? void 0 : _a.clientCountCallback(response.data.clientCount);\n                break;\n            }\n            case MessageType.BROADCAST_ACK: {\n                (_b = this.ackRequests.get(requestId)) === null || _b === void 0 ? void 0 : _b.ack(response.data.packet);\n                break;\n            }\n            case MessageType.FETCH_SOCKETS_RESPONSE: {\n                const request = this.requests.get(requestId);\n                if (!request) {\n                    return;\n                }\n                request.current++;\n                response.data.sockets.forEach((socket) => request.responses.push(socket));\n                if (request.current === request.expected) {\n                    clearTimeout(request.timeout);\n                    request.resolve(request.responses);\n                    this.requests.delete(requestId);\n                }\n                break;\n            }\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE: {\n                const request = this.requests.get(requestId);\n                if (!request) {\n                    return;\n                }\n                request.current++;\n                request.responses.push(response.data.packet);\n                if (request.current === request.expected) {\n                    clearTimeout(request.timeout);\n                    request.resolve(null, request.responses);\n                    this.requests.delete(requestId);\n                }\n                break;\n            }\n            default:\n                // @ts-ignore\n                debug(\"[%s] unknown response type: %s\", this.uid, response.type);\n        }\n    }\n    async broadcast(packet, opts) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                const offset = await this.publishAndReturnOffset({\n                    type: MessageType.BROADCAST,\n                    data: {\n                        packet,\n                        opts: encodeOptions(opts),\n                    },\n                });\n                this.addOffsetIfNecessary(packet, opts, offset);\n            }\n            catch (e) {\n                return debug(\"[%s] error while broadcasting message: %s\", this.uid, e.message);\n            }\n        }\n        super.broadcast(packet, opts);\n    }\n    /**\n     * Adds an offset at the end of the data array in order to allow the client to receive any missed packets when it\n     * reconnects after a temporary disconnection.\n     *\n     * @param packet\n     * @param opts\n     * @param offset\n     * @private\n     */\n    addOffsetIfNecessary(packet, opts, offset) {\n        var _a;\n        if (!this.nsp.server.opts.connectionStateRecovery) {\n            return;\n        }\n        const isEventPacket = packet.type === 2;\n        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and\n        // restored on another server upon reconnection\n        const withoutAcknowledgement = packet.id === undefined;\n        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;\n        if (isEventPacket && withoutAcknowledgement && notVolatile) {\n            packet.data.push(offset);\n        }\n    }\n    broadcastWithAck(packet, opts, clientCountCallback, ack) {\n        var _a;\n        const onlyLocal = (_a = opts === null || opts === void 0 ? void 0 : opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            const requestId = randomId();\n            this.ackRequests.set(requestId, {\n                clientCountCallback,\n                ack,\n            });\n            this.publish({\n                type: MessageType.BROADCAST,\n                data: {\n                    packet,\n                    requestId,\n                    opts: encodeOptions(opts),\n                },\n            });\n            // we have no way to know at this level whether the server has received an acknowledgement from each client, so we\n            // will simply clean up the ackRequests map after the given delay\n            setTimeout(() => {\n                this.ackRequests.delete(requestId);\n            }, opts.flags.timeout);\n        }\n        super.broadcastWithAck(packet, opts, clientCountCallback, ack);\n    }\n    async addSockets(opts, rooms) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.SOCKETS_JOIN,\n                    data: {\n                        opts: encodeOptions(opts),\n                        rooms,\n                    },\n                });\n            }\n            catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.addSockets(opts, rooms);\n    }\n    async delSockets(opts, rooms) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.SOCKETS_LEAVE,\n                    data: {\n                        opts: encodeOptions(opts),\n                        rooms,\n                    },\n                });\n            }\n            catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.delSockets(opts, rooms);\n    }\n    async disconnectSockets(opts, close) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.DISCONNECT_SOCKETS,\n                    data: {\n                        opts: encodeOptions(opts),\n                        close,\n                    },\n                });\n            }\n            catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.disconnectSockets(opts, close);\n    }\n    async fetchSockets(opts) {\n        var _a;\n        const [localSockets, serverCount] = await Promise.all([\n            super.fetchSockets(opts),\n            this.serverCount(),\n        ]);\n        const expectedResponseCount = serverCount - 1;\n        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {\n            return localSockets;\n        }\n        const requestId = randomId();\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                const storedRequest = this.requests.get(requestId);\n                if (storedRequest) {\n                    reject(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`));\n                    this.requests.delete(requestId);\n                }\n            }, opts.flags.timeout || DEFAULT_TIMEOUT);\n            const storedRequest = {\n                type: MessageType.FETCH_SOCKETS,\n                resolve,\n                timeout,\n                current: 0,\n                expected: expectedResponseCount,\n                responses: localSockets,\n            };\n            this.requests.set(requestId, storedRequest);\n            this.publish({\n                type: MessageType.FETCH_SOCKETS,\n                data: {\n                    opts: encodeOptions(opts),\n                    requestId,\n                },\n            });\n        });\n    }\n    async serverSideEmit(packet) {\n        const withAck = typeof packet[packet.length - 1] === \"function\";\n        if (!withAck) {\n            return this.publish({\n                type: MessageType.SERVER_SIDE_EMIT,\n                data: {\n                    packet,\n                },\n            });\n        }\n        const ack = packet.pop();\n        const expectedResponseCount = (await this.serverCount()) - 1;\n        debug('[%s] waiting for %d responses to \"serverSideEmit\" request', this.uid, expectedResponseCount);\n        if (expectedResponseCount <= 0) {\n            return ack(null, []);\n        }\n        const requestId = randomId();\n        const timeout = setTimeout(() => {\n            const storedRequest = this.requests.get(requestId);\n            if (storedRequest) {\n                ack(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`), storedRequest.responses);\n                this.requests.delete(requestId);\n            }\n        }, DEFAULT_TIMEOUT);\n        const storedRequest = {\n            type: MessageType.SERVER_SIDE_EMIT,\n            resolve: ack,\n            timeout,\n            current: 0,\n            expected: expectedResponseCount,\n            responses: [],\n        };\n        this.requests.set(requestId, storedRequest);\n        this.publish({\n            type: MessageType.SERVER_SIDE_EMIT,\n            data: {\n                requestId,\n                packet,\n            },\n        });\n    }\n    publish(message) {\n        this.publishAndReturnOffset(message).catch((err) => {\n            debug(\"[%s] error while publishing message: %s\", this.uid, err);\n        });\n    }\n    publishAndReturnOffset(message) {\n        message.uid = this.uid;\n        message.nsp = this.nsp.name;\n        return this.doPublish(message);\n    }\n    publishResponse(requesterUid, response) {\n        response.uid = this.uid;\n        response.nsp = this.nsp.name;\n        this.doPublishResponse(requesterUid, response).catch((err) => {\n            debug(\"[%s] error while publishing response: %s\", this.uid, err);\n        });\n    }\n}\nexports.ClusterAdapter = ClusterAdapter;\nclass ClusterAdapterWithHeartbeat extends ClusterAdapter {\n    constructor(nsp, opts) {\n        super(nsp);\n        this.nodesMap = new Map(); // uid => timestamp of last message\n        this.customRequests = new Map();\n        this._opts = Object.assign({\n            heartbeatInterval: 5000,\n            heartbeatTimeout: 10000,\n        }, opts);\n        this.cleanupTimer = setInterval(() => {\n            const now = Date.now();\n            this.nodesMap.forEach((lastSeen, uid) => {\n                const nodeSeemsDown = now - lastSeen > this._opts.heartbeatTimeout;\n                if (nodeSeemsDown) {\n                    debug(\"[%s] node %s seems down\", this.uid, uid);\n                    this.removeNode(uid);\n                }\n            });\n        }, 1000);\n    }\n    init() {\n        this.publish({\n            type: MessageType.INITIAL_HEARTBEAT,\n        });\n    }\n    scheduleHeartbeat() {\n        if (this.heartbeatTimer) {\n            this.heartbeatTimer.refresh();\n        }\n        else {\n            this.heartbeatTimer = setTimeout(() => {\n                this.publish({\n                    type: MessageType.HEARTBEAT,\n                });\n            }, this._opts.heartbeatInterval);\n        }\n    }\n    close() {\n        this.publish({\n            type: MessageType.ADAPTER_CLOSE,\n        });\n        clearTimeout(this.heartbeatTimer);\n        if (this.cleanupTimer) {\n            clearInterval(this.cleanupTimer);\n        }\n    }\n    onMessage(message, offset) {\n        if (message.uid === this.uid) {\n            return debug(\"[%s] ignore message from self\", this.uid);\n        }\n        if (message.uid && message.uid !== EMITTER_UID) {\n            // we track the UID of each sender, in order to know how many servers there are in the cluster\n            this.nodesMap.set(message.uid, Date.now());\n        }\n        debug(\"[%s] new event of type %d from %s\", this.uid, message.type, message.uid);\n        switch (message.type) {\n            case MessageType.INITIAL_HEARTBEAT:\n                this.publish({\n                    type: MessageType.HEARTBEAT,\n                });\n                break;\n            case MessageType.HEARTBEAT:\n                // nothing to do\n                break;\n            case MessageType.ADAPTER_CLOSE:\n                this.removeNode(message.uid);\n                break;\n            default:\n                super.onMessage(message, offset);\n        }\n    }\n    serverCount() {\n        return Promise.resolve(1 + this.nodesMap.size);\n    }\n    publish(message) {\n        this.scheduleHeartbeat();\n        return super.publish(message);\n    }\n    async serverSideEmit(packet) {\n        const withAck = typeof packet[packet.length - 1] === \"function\";\n        if (!withAck) {\n            return this.publish({\n                type: MessageType.SERVER_SIDE_EMIT,\n                data: {\n                    packet,\n                },\n            });\n        }\n        const ack = packet.pop();\n        const expectedResponseCount = this.nodesMap.size;\n        debug('[%s] waiting for %d responses to \"serverSideEmit\" request', this.uid, expectedResponseCount);\n        if (expectedResponseCount <= 0) {\n            return ack(null, []);\n        }\n        const requestId = randomId();\n        const timeout = setTimeout(() => {\n            const storedRequest = this.customRequests.get(requestId);\n            if (storedRequest) {\n                ack(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`), storedRequest.responses);\n                this.customRequests.delete(requestId);\n            }\n        }, DEFAULT_TIMEOUT);\n        const storedRequest = {\n            type: MessageType.SERVER_SIDE_EMIT,\n            resolve: ack,\n            timeout,\n            missingUids: new Set([...this.nodesMap.keys()]),\n            responses: [],\n        };\n        this.customRequests.set(requestId, storedRequest);\n        this.publish({\n            type: MessageType.SERVER_SIDE_EMIT,\n            data: {\n                requestId,\n                packet,\n            },\n        });\n    }\n    async fetchSockets(opts) {\n        var _a;\n        const [localSockets, serverCount] = await Promise.all([\n            super.fetchSockets({\n                rooms: opts.rooms,\n                except: opts.except,\n                flags: {\n                    local: true,\n                },\n            }),\n            this.serverCount(),\n        ]);\n        const expectedResponseCount = serverCount - 1;\n        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {\n            return localSockets;\n        }\n        const requestId = randomId();\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                const storedRequest = this.customRequests.get(requestId);\n                if (storedRequest) {\n                    reject(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`));\n                    this.customRequests.delete(requestId);\n                }\n            }, opts.flags.timeout || DEFAULT_TIMEOUT);\n            const storedRequest = {\n                type: MessageType.FETCH_SOCKETS,\n                resolve,\n                timeout,\n                missingUids: new Set([...this.nodesMap.keys()]),\n                responses: localSockets,\n            };\n            this.customRequests.set(requestId, storedRequest);\n            this.publish({\n                type: MessageType.FETCH_SOCKETS,\n                data: {\n                    opts: encodeOptions(opts),\n                    requestId,\n                },\n            });\n        });\n    }\n    onResponse(response) {\n        const requestId = response.data.requestId;\n        debug(\"[%s] received response %s to request %s\", this.uid, response.type, requestId);\n        switch (response.type) {\n            case MessageType.FETCH_SOCKETS_RESPONSE: {\n                const request = this.customRequests.get(requestId);\n                if (!request) {\n                    return;\n                }\n                response.data.sockets.forEach((socket) => request.responses.push(socket));\n                request.missingUids.delete(response.uid);\n                if (request.missingUids.size === 0) {\n                    clearTimeout(request.timeout);\n                    request.resolve(request.responses);\n                    this.customRequests.delete(requestId);\n                }\n                break;\n            }\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE: {\n                const request = this.customRequests.get(requestId);\n                if (!request) {\n                    return;\n                }\n                request.responses.push(response.data.packet);\n                request.missingUids.delete(response.uid);\n                if (request.missingUids.size === 0) {\n                    clearTimeout(request.timeout);\n                    request.resolve(null, request.responses);\n                    this.customRequests.delete(requestId);\n                }\n                break;\n            }\n            default:\n                super.onResponse(response);\n        }\n    }\n    removeNode(uid) {\n        this.customRequests.forEach((request, requestId) => {\n            request.missingUids.delete(uid);\n            if (request.missingUids.size === 0) {\n                clearTimeout(request.timeout);\n                if (request.type === MessageType.FETCH_SOCKETS) {\n                    request.resolve(request.responses);\n                }\n                else if (request.type === MessageType.SERVER_SIDE_EMIT) {\n                    request.resolve(null, request.responses);\n                }\n                this.customRequests.delete(requestId);\n            }\n        });\n        this.nodesMap.delete(uid);\n    }\n}\nexports.ClusterAdapterWithHeartbeat = ClusterAdapterWithHeartbeat;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9jbHVzdGVyLWFkYXB0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQ0FBbUMsR0FBRyxzQkFBc0IsR0FBRyxtQkFBbUI7QUFDbEYsNEJBQTRCLG1CQUFPLENBQUMsNkZBQXFCO0FBQ3pELGdCQUFnQixtQkFBTyxDQUFDLHNEQUFPO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDLG1CQUFtQixLQUFLO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDLEtBQUs7QUFDckQsV0FBVyxnQ0FBZ0MsS0FBSztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsZUFBZTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx1QkFBdUIsNEJBQTRCLHVCQUF1QjtBQUN4STtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHVCQUF1Qiw0QkFBNEIsdUJBQXVCO0FBQ2pJO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGdDQUFnQztBQUMxRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0NBQWdDO0FBQ2pHO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsiL1ZvbHVtZXMvU29ubmFMYWJzL0hldGljL2RhdGEtdGVjaC1uZXh0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tYWRhcHRlci9kaXN0L2NsdXN0ZXItYWRhcHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2x1c3RlckFkYXB0ZXJXaXRoSGVhcnRiZWF0ID0gZXhwb3J0cy5DbHVzdGVyQWRhcHRlciA9IGV4cG9ydHMuTWVzc2FnZVR5cGUgPSB2b2lkIDA7XG5jb25zdCBpbl9tZW1vcnlfYWRhcHRlcl8xID0gcmVxdWlyZShcIi4vaW4tbWVtb3J5LWFkYXB0ZXJcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWJ1ZykoXCJzb2NrZXQuaW8tYWRhcHRlclwiKTtcbmNvbnN0IEVNSVRURVJfVUlEID0gXCJlbWl0dGVyXCI7XG5jb25zdCBERUZBVUxUX1RJTUVPVVQgPSA1MDAwO1xuZnVuY3Rpb24gcmFuZG9tSWQoKSB7XG4gICAgcmV0dXJuICgwLCBjcnlwdG9fMS5yYW5kb21CeXRlcykoOCkudG9TdHJpbmcoXCJoZXhcIik7XG59XG52YXIgTWVzc2FnZVR5cGU7XG4oZnVuY3Rpb24gKE1lc3NhZ2VUeXBlKSB7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJJTklUSUFMX0hFQVJUQkVBVFwiXSA9IDFdID0gXCJJTklUSUFMX0hFQVJUQkVBVFwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiSEVBUlRCRUFUXCJdID0gMl0gPSBcIkhFQVJUQkVBVFwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiQlJPQURDQVNUXCJdID0gM10gPSBcIkJST0FEQ0FTVFwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiU09DS0VUU19KT0lOXCJdID0gNF0gPSBcIlNPQ0tFVFNfSk9JTlwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiU09DS0VUU19MRUFWRVwiXSA9IDVdID0gXCJTT0NLRVRTX0xFQVZFXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJESVNDT05ORUNUX1NPQ0tFVFNcIl0gPSA2XSA9IFwiRElTQ09OTkVDVF9TT0NLRVRTXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJGRVRDSF9TT0NLRVRTXCJdID0gN10gPSBcIkZFVENIX1NPQ0tFVFNcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkZFVENIX1NPQ0tFVFNfUkVTUE9OU0VcIl0gPSA4XSA9IFwiRkVUQ0hfU09DS0VUU19SRVNQT05TRVwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiU0VSVkVSX1NJREVfRU1JVFwiXSA9IDldID0gXCJTRVJWRVJfU0lERV9FTUlUXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJTRVJWRVJfU0lERV9FTUlUX1JFU1BPTlNFXCJdID0gMTBdID0gXCJTRVJWRVJfU0lERV9FTUlUX1JFU1BPTlNFXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJCUk9BRENBU1RfQ0xJRU5UX0NPVU5UXCJdID0gMTFdID0gXCJCUk9BRENBU1RfQ0xJRU5UX0NPVU5UXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJCUk9BRENBU1RfQUNLXCJdID0gMTJdID0gXCJCUk9BRENBU1RfQUNLXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJBREFQVEVSX0NMT1NFXCJdID0gMTNdID0gXCJBREFQVEVSX0NMT1NFXCI7XG59KShNZXNzYWdlVHlwZSA9IGV4cG9ydHMuTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMuTWVzc2FnZVR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZW5jb2RlT3B0aW9ucyhvcHRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9vbXM6IFsuLi5vcHRzLnJvb21zXSxcbiAgICAgICAgZXhjZXB0OiBbLi4ub3B0cy5leGNlcHRdLFxuICAgICAgICBmbGFnczogb3B0cy5mbGFncyxcbiAgICB9O1xufVxuZnVuY3Rpb24gZGVjb2RlT3B0aW9ucyhvcHRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9vbXM6IG5ldyBTZXQob3B0cy5yb29tcyksXG4gICAgICAgIGV4Y2VwdDogbmV3IFNldChvcHRzLmV4Y2VwdCksXG4gICAgICAgIGZsYWdzOiBvcHRzLmZsYWdzLFxuICAgIH07XG59XG4vKipcbiAqIEEgY2x1c3Rlci1yZWFkeSBhZGFwdGVyLiBBbnkgZXh0ZW5kaW5nIGNsYXNzIG11c3Q6XG4gKlxuICogLSBpbXBsZW1lbnQge0BsaW5rIENsdXN0ZXJBZGFwdGVyI2RvUHVibGlzaH0gYW5kIHtAbGluayBDbHVzdGVyQWRhcHRlciNkb1B1Ymxpc2hSZXNwb25zZX1cbiAqIC0gY2FsbCB7QGxpbmsgQ2x1c3RlckFkYXB0ZXIjb25NZXNzYWdlfSBhbmQge0BsaW5rIENsdXN0ZXJBZGFwdGVyI29uUmVzcG9uc2V9XG4gKi9cbmNsYXNzIENsdXN0ZXJBZGFwdGVyIGV4dGVuZHMgaW5fbWVtb3J5X2FkYXB0ZXJfMS5BZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihuc3ApIHtcbiAgICAgICAgc3VwZXIobnNwKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hY2tSZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy51aWQgPSByYW5kb21JZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiByZWNlaXZpbmcgYSBtZXNzYWdlIGZyb20gYW5vdGhlciBtZW1iZXIgb2YgdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25NZXNzYWdlKG1lc3NhZ2UsIG9mZnNldCkge1xuICAgICAgICBpZiAobWVzc2FnZS51aWQgPT09IHRoaXMudWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVidWcoXCJbJXNdIGlnbm9yZSBtZXNzYWdlIGZyb20gc2VsZlwiLCB0aGlzLnVpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJbJXNdIG5ldyBldmVudCBvZiB0eXBlICVkIGZyb20gJXNcIiwgdGhpcy51aWQsIG1lc3NhZ2UudHlwZSwgbWVzc2FnZS51aWQpO1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5CUk9BRENBU1Q6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3aXRoQWNrID0gbWVzc2FnZS5kYXRhLnJlcXVlc3RJZCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh3aXRoQWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmJyb2FkY2FzdFdpdGhBY2sobWVzc2FnZS5kYXRhLnBhY2tldCwgZGVjb2RlT3B0aW9ucyhtZXNzYWdlLmRhdGEub3B0cyksIChjbGllbnRDb3VudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJbJXNdIHdhaXRpbmcgZm9yICVkIGNsaWVudCBhY2tub3dsZWRnZW1lbnRzXCIsIHRoaXMudWlkLCBjbGllbnRDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXNwb25zZShtZXNzYWdlLnVpZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkJST0FEQ0FTVF9DTElFTlRfQ09VTlQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IG1lc3NhZ2UuZGF0YS5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJbJXNdIHJlY2VpdmVkIGFja25vd2xlZGdlbWVudCB3aXRoIHZhbHVlICVqXCIsIHRoaXMudWlkLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzcG9uc2UobWVzc2FnZS51aWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5CUk9BRENBU1RfQUNLLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiBtZXNzYWdlLmRhdGEucmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXQ6IGFyZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gbWVzc2FnZS5kYXRhLnBhY2tldDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0cyA9IGRlY29kZU9wdGlvbnMobWVzc2FnZS5kYXRhLm9wdHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE9mZnNldElmTmVjZXNzYXJ5KHBhY2tldCwgb3B0cywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuYnJvYWRjYXN0KHBhY2tldCwgb3B0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5TT0NLRVRTX0pPSU46XG4gICAgICAgICAgICAgICAgc3VwZXIuYWRkU29ja2V0cyhkZWNvZGVPcHRpb25zKG1lc3NhZ2UuZGF0YS5vcHRzKSwgbWVzc2FnZS5kYXRhLnJvb21zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU09DS0VUU19MRUFWRTpcbiAgICAgICAgICAgICAgICBzdXBlci5kZWxTb2NrZXRzKGRlY29kZU9wdGlvbnMobWVzc2FnZS5kYXRhLm9wdHMpLCBtZXNzYWdlLmRhdGEucm9vbXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5ESVNDT05ORUNUX1NPQ0tFVFM6XG4gICAgICAgICAgICAgICAgc3VwZXIuZGlzY29ubmVjdFNvY2tldHMoZGVjb2RlT3B0aW9ucyhtZXNzYWdlLmRhdGEub3B0cyksIG1lc3NhZ2UuZGF0YS5jbG9zZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFM6IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gY2FsbGluZyBmZXRjaFNvY2tldHMgd2l0aCBvcHRzICVqXCIsIHRoaXMudWlkLCBtZXNzYWdlLmRhdGEub3B0cyk7XG4gICAgICAgICAgICAgICAgc3VwZXJcbiAgICAgICAgICAgICAgICAgICAgLmZldGNoU29ja2V0cyhkZWNvZGVPcHRpb25zKG1lc3NhZ2UuZGF0YS5vcHRzKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGxvY2FsU29ja2V0cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXNwb25zZShtZXNzYWdlLnVpZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuRkVUQ0hfU09DS0VUU19SRVNQT05TRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IG1lc3NhZ2UuZGF0YS5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0czogbG9jYWxTb2NrZXRzLm1hcCgoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBzZXNzaW9uU3RvcmUgZnJvbSBoYW5kc2hha2UsIGFzIGl0IG1heSBjb250YWluIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX2EgPSBzb2NrZXQuaGFuZHNoYWtlLCB7IHNlc3Npb25TdG9yZSB9ID0gX2EsIGhhbmRzaGFrZSA9IF9fcmVzdChfYSwgW1wic2Vzc2lvblN0b3JlXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzb2NrZXQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kc2hha2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb29tczogWy4uLnNvY2tldC5yb29tc10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzb2NrZXQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlUOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gbWVzc2FnZS5kYXRhLnBhY2tldDtcbiAgICAgICAgICAgICAgICBjb25zdCB3aXRoQWNrID0gbWVzc2FnZS5kYXRhLnJlcXVlc3RJZCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICghd2l0aEFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5zcC5fb25TZXJ2ZXJTaWRlRW1pdChwYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBvbmUgYXJndW1lbnQgaXMgZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSBjYWxsaW5nIGFja25vd2xlZGdlbWVudCB3aXRoICVqXCIsIHRoaXMudWlkLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXNwb25zZShtZXNzYWdlLnVpZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVF9SRVNQT05TRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IG1lc3NhZ2UuZGF0YS5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0OiBhcmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMubnNwLl9vblNlcnZlclNpZGVFbWl0KFsuLi5wYWNrZXQsIGNhbGxiYWNrXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkJST0FEQ0FTVF9DTElFTlRfQ09VTlQ6XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkJST0FEQ0FTVF9BQ0s6XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFNfUkVTUE9OU0U6XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVRfUkVTUE9OU0U6XG4gICAgICAgICAgICAgICAgLy8gZXh0ZW5kaW5nIGNsYXNzZXMgbWF5IG5vdCBtYWtlIGEgZGlzdGluY3Rpb24gYmV0d2VlbiBhIENsdXN0ZXJNZXNzYWdlIGFuZCBhIENsdXN0ZXJSZXNwb25zZSBwYXlsb2FkIGFuZCBtYXlcbiAgICAgICAgICAgICAgICAvLyBhbHdheXMgY2FsbCB0aGUgb25NZXNzYWdlKCkgbWV0aG9kXG4gICAgICAgICAgICAgICAgdGhpcy5vblJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gdW5rbm93biBtZXNzYWdlIHR5cGU6ICVzXCIsIHRoaXMudWlkLCBtZXNzYWdlLnR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHJlY2VpdmluZyBhIHJlc3BvbnNlIGZyb20gYW5vdGhlciBtZW1iZXIgb2YgdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVzcG9uc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25SZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByZXNwb25zZS5kYXRhLnJlcXVlc3RJZDtcbiAgICAgICAgZGVidWcoXCJbJXNdIHJlY2VpdmVkIHJlc3BvbnNlICVzIHRvIHJlcXVlc3QgJXNcIiwgdGhpcy51aWQsIHJlc3BvbnNlLnR5cGUsIHJlcXVlc3RJZCk7XG4gICAgICAgIHN3aXRjaCAocmVzcG9uc2UudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5CUk9BRENBU1RfQ0xJRU5UX0NPVU5UOiB7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5hY2tSZXF1ZXN0c1xuICAgICAgICAgICAgICAgICAgICAuZ2V0KHJlcXVlc3RJZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGllbnRDb3VudENhbGxiYWNrKHJlc3BvbnNlLmRhdGEuY2xpZW50Q291bnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5CUk9BRENBU1RfQUNLOiB7XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5hY2tSZXF1ZXN0cy5nZXQocmVxdWVzdElkKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFjayhyZXNwb25zZS5kYXRhLnBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFNfUkVTUE9OU0U6IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXF1ZXN0LmN1cnJlbnQrKztcbiAgICAgICAgICAgICAgICByZXNwb25zZS5kYXRhLnNvY2tldHMuZm9yRWFjaCgoc29ja2V0KSA9PiByZXF1ZXN0LnJlc3BvbnNlcy5wdXNoKHNvY2tldCkpO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmN1cnJlbnQgPT09IHJlcXVlc3QuZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlcXVlc3QudGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlUX1JFU1BPTlNFOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMucmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jdXJyZW50Kys7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZXMucHVzaChyZXNwb25zZS5kYXRhLnBhY2tldCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuY3VycmVudCA9PT0gcmVxdWVzdC5leHBlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVxdWVzdC50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNvbHZlKG51bGwsIHJlcXVlc3QucmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gdW5rbm93biByZXNwb25zZSB0eXBlOiAlc1wiLCB0aGlzLnVpZCwgcmVzcG9uc2UudHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgYnJvYWRjYXN0KHBhY2tldCwgb3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9ubHlMb2NhbCA9IChfYSA9IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbDtcbiAgICAgICAgaWYgKCFvbmx5TG9jYWwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gYXdhaXQgdGhpcy5wdWJsaXNoQW5kUmV0dXJuT2Zmc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQlJPQURDQVNULFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzOiBlbmNvZGVPcHRpb25zKG9wdHMpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkT2Zmc2V0SWZOZWNlc3NhcnkocGFja2V0LCBvcHRzLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVidWcoXCJbJXNdIGVycm9yIHdoaWxlIGJyb2FkY2FzdGluZyBtZXNzYWdlOiAlc1wiLCB0aGlzLnVpZCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5icm9hZGNhc3QocGFja2V0LCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBvZmZzZXQgYXQgdGhlIGVuZCBvZiB0aGUgZGF0YSBhcnJheSBpbiBvcmRlciB0byBhbGxvdyB0aGUgY2xpZW50IHRvIHJlY2VpdmUgYW55IG1pc3NlZCBwYWNrZXRzIHdoZW4gaXRcbiAgICAgKiByZWNvbm5lY3RzIGFmdGVyIGEgdGVtcG9yYXJ5IGRpc2Nvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFja2V0XG4gICAgICogQHBhcmFtIG9wdHNcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhZGRPZmZzZXRJZk5lY2Vzc2FyeShwYWNrZXQsIG9wdHMsIG9mZnNldCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5uc3Auc2VydmVyLm9wdHMuY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0V2ZW50UGFja2V0ID0gcGFja2V0LnR5cGUgPT09IDI7XG4gICAgICAgIC8vIHBhY2tldHMgd2l0aCBhY2tub3dsZWRnZW1lbnQgYXJlIG5vdCBzdG9yZWQgYmVjYXVzZSB0aGUgYWNrbm93bGVkZ2VtZW50IGZ1bmN0aW9uIGNhbm5vdCBiZSBzZXJpYWxpemVkIGFuZFxuICAgICAgICAvLyByZXN0b3JlZCBvbiBhbm90aGVyIHNlcnZlciB1cG9uIHJlY29ubmVjdGlvblxuICAgICAgICBjb25zdCB3aXRob3V0QWNrbm93bGVkZ2VtZW50ID0gcGFja2V0LmlkID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IG5vdFZvbGF0aWxlID0gKChfYSA9IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52b2xhdGlsZSkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGlzRXZlbnRQYWNrZXQgJiYgd2l0aG91dEFja25vd2xlZGdlbWVudCAmJiBub3RWb2xhdGlsZSkge1xuICAgICAgICAgICAgcGFja2V0LmRhdGEucHVzaChvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJyb2FkY2FzdFdpdGhBY2socGFja2V0LCBvcHRzLCBjbGllbnRDb3VudENhbGxiYWNrLCBhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvbmx5TG9jYWwgPSAoX2EgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbDtcbiAgICAgICAgaWYgKCFvbmx5TG9jYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJhbmRvbUlkKCk7XG4gICAgICAgICAgICB0aGlzLmFja1JlcXVlc3RzLnNldChyZXF1ZXN0SWQsIHtcbiAgICAgICAgICAgICAgICBjbGllbnRDb3VudENhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGFjayxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5CUk9BRENBU1QsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBwYWNrZXQsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgb3B0czogZW5jb2RlT3B0aW9ucyhvcHRzKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIG5vIHdheSB0byBrbm93IGF0IHRoaXMgbGV2ZWwgd2hldGhlciB0aGUgc2VydmVyIGhhcyByZWNlaXZlZCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSBlYWNoIGNsaWVudCwgc28gd2VcbiAgICAgICAgICAgIC8vIHdpbGwgc2ltcGx5IGNsZWFuIHVwIHRoZSBhY2tSZXF1ZXN0cyBtYXAgYWZ0ZXIgdGhlIGdpdmVuIGRlbGF5XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFja1JlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgfSwgb3B0cy5mbGFncy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5icm9hZGNhc3RXaXRoQWNrKHBhY2tldCwgb3B0cywgY2xpZW50Q291bnRDYWxsYmFjaywgYWNrKTtcbiAgICB9XG4gICAgYXN5bmMgYWRkU29ja2V0cyhvcHRzLCByb29tcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9ubHlMb2NhbCA9IChfYSA9IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbDtcbiAgICAgICAgaWYgKCFvbmx5TG9jYWwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoQW5kUmV0dXJuT2Zmc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU09DS0VUU19KT0lOLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzOiBlbmNvZGVPcHRpb25zKG9wdHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vbXMsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSBlcnJvciB3aGlsZSBwdWJsaXNoaW5nIG1lc3NhZ2U6ICVzXCIsIHRoaXMudWlkLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmFkZFNvY2tldHMob3B0cywgcm9vbXMpO1xuICAgIH1cbiAgICBhc3luYyBkZWxTb2NrZXRzKG9wdHMsIHJvb21zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgb25seUxvY2FsID0gKF9hID0gb3B0cy5mbGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsO1xuICAgICAgICBpZiAoIW9ubHlMb2NhbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hBbmRSZXR1cm5PZmZzZXQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TT0NLRVRTX0xFQVZFLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzOiBlbmNvZGVPcHRpb25zKG9wdHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vbXMsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSBlcnJvciB3aGlsZSBwdWJsaXNoaW5nIG1lc3NhZ2U6ICVzXCIsIHRoaXMudWlkLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmRlbFNvY2tldHMob3B0cywgcm9vbXMpO1xuICAgIH1cbiAgICBhc3luYyBkaXNjb25uZWN0U29ja2V0cyhvcHRzLCBjbG9zZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9ubHlMb2NhbCA9IChfYSA9IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbDtcbiAgICAgICAgaWYgKCFvbmx5TG9jYWwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoQW5kUmV0dXJuT2Zmc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuRElTQ09OTkVDVF9TT0NLRVRTLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzOiBlbmNvZGVPcHRpb25zKG9wdHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSBlcnJvciB3aGlsZSBwdWJsaXNoaW5nIG1lc3NhZ2U6ICVzXCIsIHRoaXMudWlkLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmRpc2Nvbm5lY3RTb2NrZXRzKG9wdHMsIGNsb3NlKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hTb2NrZXRzKG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBbbG9jYWxTb2NrZXRzLCBzZXJ2ZXJDb3VudF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBzdXBlci5mZXRjaFNvY2tldHMob3B0cyksXG4gICAgICAgICAgICB0aGlzLnNlcnZlckNvdW50KCksXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBleHBlY3RlZFJlc3BvbnNlQ291bnQgPSBzZXJ2ZXJDb3VudCAtIDE7XG4gICAgICAgIGlmICgoKF9hID0gb3B0cy5mbGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsKSB8fCBleHBlY3RlZFJlc3BvbnNlQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU29ja2V0cztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByYW5kb21JZCgpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlZFJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIGlmIChzdG9yZWRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYHRpbWVvdXQgcmVhY2hlZDogb25seSAke3N0b3JlZFJlcXVlc3QuY3VycmVudH0gcmVzcG9uc2VzIHJlY2VpdmVkIG91dCBvZiAke3N0b3JlZFJlcXVlc3QuZXhwZWN0ZWR9YCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG9wdHMuZmxhZ3MudGltZW91dCB8fCBERUZBVUxUX1RJTUVPVVQpO1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTLFxuICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgICAgICBjdXJyZW50OiAwLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZFJlc3BvbnNlQ291bnQsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VzOiBsb2NhbFNvY2tldHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0cy5zZXQocmVxdWVzdElkLCBzdG9yZWRSZXF1ZXN0KTtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuRkVUQ0hfU09DS0VUUyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHM6IGVuY29kZU9wdGlvbnMob3B0cyksXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzZXJ2ZXJTaWRlRW1pdChwYWNrZXQpIHtcbiAgICAgICAgY29uc3Qgd2l0aEFjayA9IHR5cGVvZiBwYWNrZXRbcGFja2V0Lmxlbmd0aCAtIDFdID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGlmICghd2l0aEFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVCxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhY2tldCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNrID0gcGFja2V0LnBvcCgpO1xuICAgICAgICBjb25zdCBleHBlY3RlZFJlc3BvbnNlQ291bnQgPSAoYXdhaXQgdGhpcy5zZXJ2ZXJDb3VudCgpKSAtIDE7XG4gICAgICAgIGRlYnVnKCdbJXNdIHdhaXRpbmcgZm9yICVkIHJlc3BvbnNlcyB0byBcInNlcnZlclNpZGVFbWl0XCIgcmVxdWVzdCcsIHRoaXMudWlkLCBleHBlY3RlZFJlc3BvbnNlQ291bnQpO1xuICAgICAgICBpZiAoZXhwZWN0ZWRSZXNwb25zZUNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhY2sobnVsbCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJhbmRvbUlkKCk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgaWYgKHN0b3JlZFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBhY2sobmV3IEVycm9yKGB0aW1lb3V0IHJlYWNoZWQ6IG9ubHkgJHtzdG9yZWRSZXF1ZXN0LmN1cnJlbnR9IHJlc3BvbnNlcyByZWNlaXZlZCBvdXQgb2YgJHtzdG9yZWRSZXF1ZXN0LmV4cGVjdGVkfWApLCBzdG9yZWRSZXF1ZXN0LnJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgREVGQVVMVF9USU1FT1VUKTtcbiAgICAgICAgY29uc3Qgc3RvcmVkUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVQsXG4gICAgICAgICAgICByZXNvbHZlOiBhY2ssXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgY3VycmVudDogMCxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZFJlc3BvbnNlQ291bnQsXG4gICAgICAgICAgICByZXNwb25zZXM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlcXVlc3RzLnNldChyZXF1ZXN0SWQsIHN0b3JlZFJlcXVlc3QpO1xuICAgICAgICB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgcGFja2V0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHB1Ymxpc2gobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnB1Ymxpc2hBbmRSZXR1cm5PZmZzZXQobWVzc2FnZSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJbJXNdIGVycm9yIHdoaWxlIHB1Ymxpc2hpbmcgbWVzc2FnZTogJXNcIiwgdGhpcy51aWQsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwdWJsaXNoQW5kUmV0dXJuT2Zmc2V0KG1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZS51aWQgPSB0aGlzLnVpZDtcbiAgICAgICAgbWVzc2FnZS5uc3AgPSB0aGlzLm5zcC5uYW1lO1xuICAgICAgICByZXR1cm4gdGhpcy5kb1B1Ymxpc2gobWVzc2FnZSk7XG4gICAgfVxuICAgIHB1Ymxpc2hSZXNwb25zZShyZXF1ZXN0ZXJVaWQsIHJlc3BvbnNlKSB7XG4gICAgICAgIHJlc3BvbnNlLnVpZCA9IHRoaXMudWlkO1xuICAgICAgICByZXNwb25zZS5uc3AgPSB0aGlzLm5zcC5uYW1lO1xuICAgICAgICB0aGlzLmRvUHVibGlzaFJlc3BvbnNlKHJlcXVlc3RlclVpZCwgcmVzcG9uc2UpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwiWyVzXSBlcnJvciB3aGlsZSBwdWJsaXNoaW5nIHJlc3BvbnNlOiAlc1wiLCB0aGlzLnVpZCwgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5DbHVzdGVyQWRhcHRlciA9IENsdXN0ZXJBZGFwdGVyO1xuY2xhc3MgQ2x1c3RlckFkYXB0ZXJXaXRoSGVhcnRiZWF0IGV4dGVuZHMgQ2x1c3RlckFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG5zcCwgb3B0cykge1xuICAgICAgICBzdXBlcihuc3ApO1xuICAgICAgICB0aGlzLm5vZGVzTWFwID0gbmV3IE1hcCgpOyAvLyB1aWQgPT4gdGltZXN0YW1wIG9mIGxhc3QgbWVzc2FnZVxuICAgICAgICB0aGlzLmN1c3RvbVJlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9vcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBoZWFydGJlYXRJbnRlcnZhbDogNTAwMCxcbiAgICAgICAgICAgIGhlYXJ0YmVhdFRpbWVvdXQ6IDEwMDAwLFxuICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlc01hcC5mb3JFYWNoKChsYXN0U2VlbiwgdWlkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVNlZW1zRG93biA9IG5vdyAtIGxhc3RTZWVuID4gdGhpcy5fb3B0cy5oZWFydGJlYXRUaW1lb3V0O1xuICAgICAgICAgICAgICAgIGlmIChub2RlU2VlbXNEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSBub2RlICVzIHNlZW1zIGRvd25cIiwgdGhpcy51aWQsIHVpZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZSh1aWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCAxMDAwKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLklOSVRJQUxfSEVBUlRCRUFULFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2NoZWR1bGVIZWFydGJlYXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYXJ0YmVhdFRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5IRUFSVEJFQVQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzLl9vcHRzLmhlYXJ0YmVhdEludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkFEQVBURVJfQ0xPU0UsXG4gICAgICAgIH0pO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFydGJlYXRUaW1lcik7XG4gICAgICAgIGlmICh0aGlzLmNsZWFudXBUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNsZWFudXBUaW1lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25NZXNzYWdlKG1lc3NhZ2UsIG9mZnNldCkge1xuICAgICAgICBpZiAobWVzc2FnZS51aWQgPT09IHRoaXMudWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVidWcoXCJbJXNdIGlnbm9yZSBtZXNzYWdlIGZyb20gc2VsZlwiLCB0aGlzLnVpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudWlkICYmIG1lc3NhZ2UudWlkICE9PSBFTUlUVEVSX1VJRCkge1xuICAgICAgICAgICAgLy8gd2UgdHJhY2sgdGhlIFVJRCBvZiBlYWNoIHNlbmRlciwgaW4gb3JkZXIgdG8ga25vdyBob3cgbWFueSBzZXJ2ZXJzIHRoZXJlIGFyZSBpbiB0aGUgY2x1c3RlclxuICAgICAgICAgICAgdGhpcy5ub2Rlc01hcC5zZXQobWVzc2FnZS51aWQsIERhdGUubm93KCkpO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwiWyVzXSBuZXcgZXZlbnQgb2YgdHlwZSAlZCBmcm9tICVzXCIsIHRoaXMudWlkLCBtZXNzYWdlLnR5cGUsIG1lc3NhZ2UudWlkKTtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuSU5JVElBTF9IRUFSVEJFQVQ6XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuSEVBUlRCRUFULFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5IRUFSVEJFQVQ6XG4gICAgICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5BREFQVEVSX0NMT1NFOlxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZShtZXNzYWdlLnVpZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHN1cGVyLm9uTWVzc2FnZShtZXNzYWdlLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlcnZlckNvdW50KCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKDEgKyB0aGlzLm5vZGVzTWFwLnNpemUpO1xuICAgIH1cbiAgICBwdWJsaXNoKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZUhlYXJ0YmVhdCgpO1xuICAgICAgICByZXR1cm4gc3VwZXIucHVibGlzaChtZXNzYWdlKTtcbiAgICB9XG4gICAgYXN5bmMgc2VydmVyU2lkZUVtaXQocGFja2V0KSB7XG4gICAgICAgIGNvbnN0IHdpdGhBY2sgPSB0eXBlb2YgcGFja2V0W3BhY2tldC5sZW5ndGggLSAxXSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICBpZiAoIXdpdGhBY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVQsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBwYWNrZXQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjayA9IHBhY2tldC5wb3AoKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRSZXNwb25zZUNvdW50ID0gdGhpcy5ub2Rlc01hcC5zaXplO1xuICAgICAgICBkZWJ1ZygnWyVzXSB3YWl0aW5nIGZvciAlZCByZXNwb25zZXMgdG8gXCJzZXJ2ZXJTaWRlRW1pdFwiIHJlcXVlc3QnLCB0aGlzLnVpZCwgZXhwZWN0ZWRSZXNwb25zZUNvdW50KTtcbiAgICAgICAgaWYgKGV4cGVjdGVkUmVzcG9uc2VDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNrKG51bGwsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByYW5kb21JZCgpO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWRSZXF1ZXN0ID0gdGhpcy5jdXN0b21SZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgIGlmIChzdG9yZWRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgYWNrKG5ldyBFcnJvcihgdGltZW91dCByZWFjaGVkOiBtaXNzaW5nICR7c3RvcmVkUmVxdWVzdC5taXNzaW5nVWlkcy5zaXplfSByZXNwb25zZXNgKSwgc3RvcmVkUmVxdWVzdC5yZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIERFRkFVTFRfVElNRU9VVCk7XG4gICAgICAgIGNvbnN0IHN0b3JlZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlULFxuICAgICAgICAgICAgcmVzb2x2ZTogYWNrLFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIG1pc3NpbmdVaWRzOiBuZXcgU2V0KFsuLi50aGlzLm5vZGVzTWFwLmtleXMoKV0pLFxuICAgICAgICAgICAgcmVzcG9uc2VzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0cy5zZXQocmVxdWVzdElkLCBzdG9yZWRSZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVQsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgIHBhY2tldCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFNvY2tldHMob3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IFtsb2NhbFNvY2tldHMsIHNlcnZlckNvdW50XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHN1cGVyLmZldGNoU29ja2V0cyh7XG4gICAgICAgICAgICAgICAgcm9vbXM6IG9wdHMucm9vbXMsXG4gICAgICAgICAgICAgICAgZXhjZXB0OiBvcHRzLmV4Y2VwdCxcbiAgICAgICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzLnNlcnZlckNvdW50KCksXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBleHBlY3RlZFJlc3BvbnNlQ291bnQgPSBzZXJ2ZXJDb3VudCAtIDE7XG4gICAgICAgIGlmICgoKF9hID0gb3B0cy5mbGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsKSB8fCBleHBlY3RlZFJlc3BvbnNlQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU29ja2V0cztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByYW5kb21JZCgpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlZFJlcXVlc3QgPSB0aGlzLmN1c3RvbVJlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIGlmIChzdG9yZWRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYHRpbWVvdXQgcmVhY2hlZDogbWlzc2luZyAke3N0b3JlZFJlcXVlc3QubWlzc2luZ1VpZHMuc2l6ZX0gcmVzcG9uc2VzYCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG9wdHMuZmxhZ3MudGltZW91dCB8fCBERUZBVUxUX1RJTUVPVVQpO1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTLFxuICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgICAgICBtaXNzaW5nVWlkczogbmV3IFNldChbLi4udGhpcy5ub2Rlc01hcC5rZXlzKCldKSxcbiAgICAgICAgICAgICAgICByZXNwb25zZXM6IGxvY2FsU29ja2V0cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmN1c3RvbVJlcXVlc3RzLnNldChyZXF1ZXN0SWQsIHN0b3JlZFJlcXVlc3QpO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0czogZW5jb2RlT3B0aW9ucyhvcHRzKSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmVzcG9uc2UuZGF0YS5yZXF1ZXN0SWQ7XG4gICAgICAgIGRlYnVnKFwiWyVzXSByZWNlaXZlZCByZXNwb25zZSAlcyB0byByZXF1ZXN0ICVzXCIsIHRoaXMudWlkLCByZXNwb25zZS50eXBlLCByZXF1ZXN0SWQpO1xuICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuRkVUQ0hfU09DS0VUU19SRVNQT05TRToge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmN1c3RvbVJlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEuc29ja2V0cy5mb3JFYWNoKChzb2NrZXQpID0+IHJlcXVlc3QucmVzcG9uc2VzLnB1c2goc29ja2V0KSk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5taXNzaW5nVWlkcy5kZWxldGUocmVzcG9uc2UudWlkKTtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5taXNzaW5nVWlkcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXF1ZXN0LnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc29sdmUocmVxdWVzdC5yZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVF9SRVNQT05TRToge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmN1c3RvbVJlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VzLnB1c2gocmVzcG9uc2UuZGF0YS5wYWNrZXQpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QubWlzc2luZ1VpZHMuZGVsZXRlKHJlc3BvbnNlLnVpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QubWlzc2luZ1VpZHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVxdWVzdC50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNvbHZlKG51bGwsIHJlcXVlc3QucmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHN1cGVyLm9uUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZU5vZGUodWlkKSB7XG4gICAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdHMuZm9yRWFjaCgocmVxdWVzdCwgcmVxdWVzdElkKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0Lm1pc3NpbmdVaWRzLmRlbGV0ZSh1aWQpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QubWlzc2luZ1VpZHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXF1ZXN0LnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnR5cGUgPT09IE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNvbHZlKHJlcXVlc3QucmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC50eXBlID09PSBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlUKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzb2x2ZShudWxsLCByZXF1ZXN0LnJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5vZGVzTWFwLmRlbGV0ZSh1aWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2x1c3RlckFkYXB0ZXJXaXRoSGVhcnRiZWF0ID0gQ2x1c3RlckFkYXB0ZXJXaXRoSGVhcnRiZWF0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/dist/cluster-adapter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/dist/contrib/yeast.js":
/*!**************************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/contrib/yeast.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// imported from https://github.com/unshiftio/yeast\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.yeast = exports.decode = exports.encode = void 0;\nconst alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"), length = 64, map = {};\nlet seed = 0, i = 0, prev;\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */\nfunction encode(num) {\n    let encoded = \"\";\n    do {\n        encoded = alphabet[num % length] + encoded;\n        num = Math.floor(num / length);\n    } while (num > 0);\n    return encoded;\n}\nexports.encode = encode;\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */\nfunction decode(str) {\n    let decoded = 0;\n    for (i = 0; i < str.length; i++) {\n        decoded = decoded * length + map[str.charAt(i)];\n    }\n    return decoded;\n}\nexports.decode = decode;\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */\nfunction yeast() {\n    const now = encode(+new Date());\n    if (now !== prev)\n        return (seed = 0), (prev = now);\n    return now + \".\" + encode(seed++);\n}\nexports.yeast = yeast;\n//\n// Map each character to its index.\n//\nfor (; i < length; i++)\n    map[alphabet[i]] = i;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9jb250cmliL3llYXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsT0FBTyxZQUFZO0FBQ25CIiwic291cmNlcyI6WyIvVm9sdW1lcy9Tb25uYUxhYnMvSGV0aWMvZGF0YS10ZWNoLW5leHQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1hZGFwdGVyL2Rpc3QvY29udHJpYi95ZWFzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS91bnNoaWZ0aW8veWVhc3RcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy55ZWFzdCA9IGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5lbmNvZGUgPSB2b2lkIDA7XG5jb25zdCBhbHBoYWJldCA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotX1wiLnNwbGl0KFwiXCIpLCBsZW5ndGggPSA2NCwgbWFwID0ge307XG5sZXQgc2VlZCA9IDAsIGkgPSAwLCBwcmV2O1xuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICAgIGxldCBlbmNvZGVkID0gXCJcIjtcbiAgICBkbyB7XG4gICAgICAgIGVuY29kZWQgPSBhbHBoYWJldFtudW0gJSBsZW5ndGhdICsgZW5jb2RlZDtcbiAgICAgICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICAgIH0gd2hpbGUgKG51bSA+IDApO1xuICAgIHJldHVybiBlbmNvZGVkO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vKipcbiAqIFJldHVybiB0aGUgaW50ZWdlciB2YWx1ZSBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbnRlZ2VyIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gICAgbGV0IGRlY29kZWQgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVjb2RlZCA9IGRlY29kZWQgKiBsZW5ndGggKyBtYXBbc3RyLmNoYXJBdChpKV07XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKipcbiAqIFllYXN0OiBBIHRpbnkgZ3Jvd2luZyBpZCBnZW5lcmF0b3IuXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gQSB1bmlxdWUgaWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB5ZWFzdCgpIHtcbiAgICBjb25zdCBub3cgPSBlbmNvZGUoK25ldyBEYXRlKCkpO1xuICAgIGlmIChub3cgIT09IHByZXYpXG4gICAgICAgIHJldHVybiAoc2VlZCA9IDApLCAocHJldiA9IG5vdyk7XG4gICAgcmV0dXJuIG5vdyArIFwiLlwiICsgZW5jb2RlKHNlZWQrKyk7XG59XG5leHBvcnRzLnllYXN0ID0geWVhc3Q7XG4vL1xuLy8gTWFwIGVhY2ggY2hhcmFjdGVyIHRvIGl0cyBpbmRleC5cbi8vXG5mb3IgKDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/dist/contrib/yeast.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/dist/in-memory-adapter.js":
/*!******************************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/in-memory-adapter.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SessionAwareAdapter = exports.Adapter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst yeast_1 = __webpack_require__(/*! ./contrib/yeast */ \"(rsc)/./node_modules/socket.io-adapter/dist/contrib/yeast.js\");\nconst WebSocket = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ws/index.js\");\nconst canPreComputeFrame = typeof ((_a = WebSocket === null || WebSocket === void 0 ? void 0 : WebSocket.Sender) === null || _a === void 0 ? void 0 : _a.frame) === \"function\";\nclass Adapter extends events_1.EventEmitter {\n    /**\n     * In-memory adapter constructor.\n     *\n     * @param {Namespace} nsp\n     */\n    constructor(nsp) {\n        super();\n        this.nsp = nsp;\n        this.rooms = new Map();\n        this.sids = new Map();\n        this.encoder = nsp.server.encoder;\n    }\n    /**\n     * To be overridden\n     */\n    init() { }\n    /**\n     * To be overridden\n     */\n    close() { }\n    /**\n     * Returns the number of Socket.IO servers in the cluster\n     *\n     * @public\n     */\n    serverCount() {\n        return Promise.resolve(1);\n    }\n    /**\n     * Adds a socket to a list of room.\n     *\n     * @param {SocketId}  id      the socket id\n     * @param {Set<Room>} rooms   a set of rooms\n     * @public\n     */\n    addAll(id, rooms) {\n        if (!this.sids.has(id)) {\n            this.sids.set(id, new Set());\n        }\n        for (const room of rooms) {\n            this.sids.get(id).add(room);\n            if (!this.rooms.has(room)) {\n                this.rooms.set(room, new Set());\n                this.emit(\"create-room\", room);\n            }\n            if (!this.rooms.get(room).has(id)) {\n                this.rooms.get(room).add(id);\n                this.emit(\"join-room\", room, id);\n            }\n        }\n    }\n    /**\n     * Removes a socket from a room.\n     *\n     * @param {SocketId} id     the socket id\n     * @param {Room}     room   the room name\n     */\n    del(id, room) {\n        if (this.sids.has(id)) {\n            this.sids.get(id).delete(room);\n        }\n        this._del(room, id);\n    }\n    _del(room, id) {\n        const _room = this.rooms.get(room);\n        if (_room != null) {\n            const deleted = _room.delete(id);\n            if (deleted) {\n                this.emit(\"leave-room\", room, id);\n            }\n            if (_room.size === 0 && this.rooms.delete(room)) {\n                this.emit(\"delete-room\", room);\n            }\n        }\n    }\n    /**\n     * Removes a socket from all rooms it's joined.\n     *\n     * @param {SocketId} id   the socket id\n     */\n    delAll(id) {\n        if (!this.sids.has(id)) {\n            return;\n        }\n        for (const room of this.sids.get(id)) {\n            this._del(room, id);\n        }\n        this.sids.delete(id);\n    }\n    /**\n     * Broadcasts a packet.\n     *\n     * Options:\n     *  - `flags` {Object} flags for this packet\n     *  - `except` {Array} sids that should be excluded\n     *  - `rooms` {Array} list of rooms to broadcast to\n     *\n     * @param {Object} packet   the packet object\n     * @param {Object} opts     the options\n     * @public\n     */\n    broadcast(packet, opts) {\n        const flags = opts.flags || {};\n        const packetOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress,\n        };\n        packet.nsp = this.nsp.name;\n        const encodedPackets = this._encode(packet, packetOpts);\n        this.apply(opts, (socket) => {\n            if (typeof socket.notifyOutgoingListeners === \"function\") {\n                socket.notifyOutgoingListeners(packet);\n            }\n            socket.client.writeToEngine(encodedPackets, packetOpts);\n        });\n    }\n    /**\n     * Broadcasts a packet and expects multiple acknowledgements.\n     *\n     * Options:\n     *  - `flags` {Object} flags for this packet\n     *  - `except` {Array} sids that should be excluded\n     *  - `rooms` {Array} list of rooms to broadcast to\n     *\n     * @param {Object} packet   the packet object\n     * @param {Object} opts     the options\n     * @param clientCountCallback - the number of clients that received the packet\n     * @param ack                 - the callback that will be called for each client response\n     *\n     * @public\n     */\n    broadcastWithAck(packet, opts, clientCountCallback, ack) {\n        const flags = opts.flags || {};\n        const packetOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress,\n        };\n        packet.nsp = this.nsp.name;\n        // we can use the same id for each packet, since the _ids counter is common (no duplicate)\n        packet.id = this.nsp._ids++;\n        const encodedPackets = this._encode(packet, packetOpts);\n        let clientCount = 0;\n        this.apply(opts, (socket) => {\n            // track the total number of acknowledgements that are expected\n            clientCount++;\n            // call the ack callback for each client response\n            socket.acks.set(packet.id, ack);\n            if (typeof socket.notifyOutgoingListeners === \"function\") {\n                socket.notifyOutgoingListeners(packet);\n            }\n            socket.client.writeToEngine(encodedPackets, packetOpts);\n        });\n        clientCountCallback(clientCount);\n    }\n    _encode(packet, packetOpts) {\n        const encodedPackets = this.encoder.encode(packet);\n        if (canPreComputeFrame &&\n            encodedPackets.length === 1 &&\n            typeof encodedPackets[0] === \"string\") {\n            // \"4\" being the \"message\" packet type in the Engine.IO protocol\n            const data = Buffer.from(\"4\" + encodedPackets[0]);\n            // see https://github.com/websockets/ws/issues/617#issuecomment-283002469\n            packetOpts.wsPreEncodedFrame = WebSocket.Sender.frame(data, {\n                readOnly: false,\n                mask: false,\n                rsv1: false,\n                opcode: 1,\n                fin: true,\n            });\n        }\n        return encodedPackets;\n    }\n    /**\n     * Gets a list of sockets by sid.\n     *\n     * @param {Set<Room>} rooms   the explicit set of rooms to check.\n     */\n    sockets(rooms) {\n        const sids = new Set();\n        this.apply({ rooms }, (socket) => {\n            sids.add(socket.id);\n        });\n        return Promise.resolve(sids);\n    }\n    /**\n     * Gets the list of rooms a given socket has joined.\n     *\n     * @param {SocketId} id   the socket id\n     */\n    socketRooms(id) {\n        return this.sids.get(id);\n    }\n    /**\n     * Returns the matching socket instances\n     *\n     * @param opts - the filters to apply\n     */\n    fetchSockets(opts) {\n        const sockets = [];\n        this.apply(opts, (socket) => {\n            sockets.push(socket);\n        });\n        return Promise.resolve(sockets);\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms\n     *\n     * @param opts - the filters to apply\n     * @param rooms - the rooms to join\n     */\n    addSockets(opts, rooms) {\n        this.apply(opts, (socket) => {\n            socket.join(rooms);\n        });\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms\n     *\n     * @param opts - the filters to apply\n     * @param rooms - the rooms to leave\n     */\n    delSockets(opts, rooms) {\n        this.apply(opts, (socket) => {\n            rooms.forEach((room) => socket.leave(room));\n        });\n    }\n    /**\n     * Makes the matching socket instances disconnect\n     *\n     * @param opts - the filters to apply\n     * @param close - whether to close the underlying connection\n     */\n    disconnectSockets(opts, close) {\n        this.apply(opts, (socket) => {\n            socket.disconnect(close);\n        });\n    }\n    apply(opts, callback) {\n        const rooms = opts.rooms;\n        const except = this.computeExceptSids(opts.except);\n        if (rooms.size) {\n            const ids = new Set();\n            for (const room of rooms) {\n                if (!this.rooms.has(room))\n                    continue;\n                for (const id of this.rooms.get(room)) {\n                    if (ids.has(id) || except.has(id))\n                        continue;\n                    const socket = this.nsp.sockets.get(id);\n                    if (socket) {\n                        callback(socket);\n                        ids.add(id);\n                    }\n                }\n            }\n        }\n        else {\n            for (const [id] of this.sids) {\n                if (except.has(id))\n                    continue;\n                const socket = this.nsp.sockets.get(id);\n                if (socket)\n                    callback(socket);\n            }\n        }\n    }\n    computeExceptSids(exceptRooms) {\n        const exceptSids = new Set();\n        if (exceptRooms && exceptRooms.size > 0) {\n            for (const room of exceptRooms) {\n                if (this.rooms.has(room)) {\n                    this.rooms.get(room).forEach((sid) => exceptSids.add(sid));\n                }\n            }\n        }\n        return exceptSids;\n    }\n    /**\n     * Send a packet to the other Socket.IO servers in the cluster\n     * @param packet - an array of arguments, which may include an acknowledgement callback at the end\n     */\n    serverSideEmit(packet) {\n        console.warn(\"this adapter does not support the serverSideEmit() functionality\");\n    }\n    /**\n     * Save the client session in order to restore it upon reconnection.\n     */\n    persistSession(session) { }\n    /**\n     * Restore the session and find the packets that were missed by the client.\n     * @param pid\n     * @param offset\n     */\n    restoreSession(pid, offset) {\n        return null;\n    }\n}\nexports.Adapter = Adapter;\nclass SessionAwareAdapter extends Adapter {\n    constructor(nsp) {\n        super(nsp);\n        this.nsp = nsp;\n        this.sessions = new Map();\n        this.packets = [];\n        this.maxDisconnectionDuration =\n            nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;\n        const timer = setInterval(() => {\n            const threshold = Date.now() - this.maxDisconnectionDuration;\n            this.sessions.forEach((session, sessionId) => {\n                const hasExpired = session.disconnectedAt < threshold;\n                if (hasExpired) {\n                    this.sessions.delete(sessionId);\n                }\n            });\n            for (let i = this.packets.length - 1; i >= 0; i--) {\n                const hasExpired = this.packets[i].emittedAt < threshold;\n                if (hasExpired) {\n                    this.packets.splice(0, i + 1);\n                    break;\n                }\n            }\n        }, 60 * 1000);\n        // prevents the timer from keeping the process alive\n        timer.unref();\n    }\n    persistSession(session) {\n        session.disconnectedAt = Date.now();\n        this.sessions.set(session.pid, session);\n    }\n    restoreSession(pid, offset) {\n        const session = this.sessions.get(pid);\n        if (!session) {\n            // the session may have expired\n            return null;\n        }\n        const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();\n        if (hasExpired) {\n            // the session has expired\n            this.sessions.delete(pid);\n            return null;\n        }\n        const index = this.packets.findIndex((packet) => packet.id === offset);\n        if (index === -1) {\n            // the offset may be too old\n            return null;\n        }\n        const missedPackets = [];\n        for (let i = index + 1; i < this.packets.length; i++) {\n            const packet = this.packets[i];\n            if (shouldIncludePacket(session.rooms, packet.opts)) {\n                missedPackets.push(packet.data);\n            }\n        }\n        return Promise.resolve(Object.assign(Object.assign({}, session), { missedPackets }));\n    }\n    broadcast(packet, opts) {\n        var _a;\n        const isEventPacket = packet.type === 2;\n        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and\n        // restored on another server upon reconnection\n        const withoutAcknowledgement = packet.id === undefined;\n        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;\n        if (isEventPacket && withoutAcknowledgement && notVolatile) {\n            const id = (0, yeast_1.yeast)();\n            // the offset is stored at the end of the data array, so the client knows the ID of the last packet it has\n            // processed (and the format is backward-compatible)\n            packet.data.push(id);\n            this.packets.push({\n                id,\n                opts,\n                data: packet.data,\n                emittedAt: Date.now(),\n            });\n        }\n        super.broadcast(packet, opts);\n    }\n}\nexports.SessionAwareAdapter = SessionAwareAdapter;\nfunction shouldIncludePacket(sessionRooms, opts) {\n    const included = opts.rooms.size === 0 || sessionRooms.some((room) => opts.rooms.has(room));\n    const notExcluded = sessionRooms.every((room) => !opts.except.has(room));\n    return included && notExcluded;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9pbi1tZW1vcnktYWRhcHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLGVBQWU7QUFDN0MsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMscUZBQWlCO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLDRDQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsT0FBTztBQUMzQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5QkFBeUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjLGVBQWU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL1Nvbm5hTGFicy9IZXRpYy9kYXRhLXRlY2gtbmV4dC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9pbi1tZW1vcnktYWRhcHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2Vzc2lvbkF3YXJlQWRhcHRlciA9IGV4cG9ydHMuQWRhcHRlciA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHllYXN0XzEgPSByZXF1aXJlKFwiLi9jb250cmliL3llYXN0XCIpO1xuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZShcIndzXCIpO1xuY29uc3QgY2FuUHJlQ29tcHV0ZUZyYW1lID0gdHlwZW9mICgoX2EgPSBXZWJTb2NrZXQgPT09IG51bGwgfHwgV2ViU29ja2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBXZWJTb2NrZXQuU2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJhbWUpID09PSBcImZ1bmN0aW9uXCI7XG5jbGFzcyBBZGFwdGVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBJbi1tZW1vcnkgYWRhcHRlciBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmFtZXNwYWNlfSBuc3BcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihuc3ApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uc3AgPSBuc3A7XG4gICAgICAgIHRoaXMucm9vbXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2lkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gbnNwLnNlcnZlci5lbmNvZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBiZSBvdmVycmlkZGVuXG4gICAgICovXG4gICAgaW5pdCgpIHsgfVxuICAgIC8qKlxuICAgICAqIFRvIGJlIG92ZXJyaWRkZW5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBTb2NrZXQuSU8gc2VydmVycyBpbiB0aGUgY2x1c3RlclxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNlcnZlckNvdW50KCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc29ja2V0IHRvIGEgbGlzdCBvZiByb29tLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTb2NrZXRJZH0gIGlkICAgICAgdGhlIHNvY2tldCBpZFxuICAgICAqIEBwYXJhbSB7U2V0PFJvb20+fSByb29tcyAgIGEgc2V0IG9mIHJvb21zXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGFkZEFsbChpZCwgcm9vbXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpZHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5zaWRzLnNldChpZCwgbmV3IFNldCgpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHJvb20gb2Ygcm9vbXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2lkcy5nZXQoaWQpLmFkZChyb29tKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yb29tcy5oYXMocm9vbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb21zLnNldChyb29tLCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNyZWF0ZS1yb29tXCIsIHJvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJvb21zLmdldChyb29tKS5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb29tcy5nZXQocm9vbSkuYWRkKGlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJqb2luLXJvb21cIiwgcm9vbSwgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzb2NrZXQgZnJvbSBhIHJvb20uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NvY2tldElkfSBpZCAgICAgdGhlIHNvY2tldCBpZFxuICAgICAqIEBwYXJhbSB7Um9vbX0gICAgIHJvb20gICB0aGUgcm9vbSBuYW1lXG4gICAgICovXG4gICAgZGVsKGlkLCByb29tKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5zaWRzLmdldChpZCkuZGVsZXRlKHJvb20pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlbChyb29tLCBpZCk7XG4gICAgfVxuICAgIF9kZWwocm9vbSwgaWQpIHtcbiAgICAgICAgY29uc3QgX3Jvb20gPSB0aGlzLnJvb21zLmdldChyb29tKTtcbiAgICAgICAgaWYgKF9yb29tICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSBfcm9vbS5kZWxldGUoaWQpO1xuICAgICAgICAgICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJsZWF2ZS1yb29tXCIsIHJvb20sIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfcm9vbS5zaXplID09PSAwICYmIHRoaXMucm9vbXMuZGVsZXRlKHJvb20pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVsZXRlLXJvb21cIiwgcm9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHNvY2tldCBmcm9tIGFsbCByb29tcyBpdCdzIGpvaW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U29ja2V0SWR9IGlkICAgdGhlIHNvY2tldCBpZFxuICAgICAqL1xuICAgIGRlbEFsbChpZCkge1xuICAgICAgICBpZiAoIXRoaXMuc2lkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCByb29tIG9mIHRoaXMuc2lkcy5nZXQoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWwocm9vbSwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lkcy5kZWxldGUoaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCcm9hZGNhc3RzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogT3B0aW9uczpcbiAgICAgKiAgLSBgZmxhZ3NgIHtPYmplY3R9IGZsYWdzIGZvciB0aGlzIHBhY2tldFxuICAgICAqICAtIGBleGNlcHRgIHtBcnJheX0gc2lkcyB0aGF0IHNob3VsZCBiZSBleGNsdWRlZFxuICAgICAqICAtIGByb29tc2Age0FycmF5fSBsaXN0IG9mIHJvb21zIHRvIGJyb2FkY2FzdCB0b1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAgIHRoZSBwYWNrZXQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgICAgIHRoZSBvcHRpb25zXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGJyb2FkY2FzdChwYWNrZXQsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBvcHRzLmZsYWdzIHx8IHt9O1xuICAgICAgICBjb25zdCBwYWNrZXRPcHRzID0ge1xuICAgICAgICAgICAgcHJlRW5jb2RlZDogdHJ1ZSxcbiAgICAgICAgICAgIHZvbGF0aWxlOiBmbGFncy52b2xhdGlsZSxcbiAgICAgICAgICAgIGNvbXByZXNzOiBmbGFncy5jb21wcmVzcyxcbiAgICAgICAgfTtcbiAgICAgICAgcGFja2V0Lm5zcCA9IHRoaXMubnNwLm5hbWU7XG4gICAgICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gdGhpcy5fZW5jb2RlKHBhY2tldCwgcGFja2V0T3B0cyk7XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb2NrZXQubm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHNvY2tldC5ub3RpZnlPdXRnb2luZ0xpc3RlbmVycyhwYWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ja2V0LmNsaWVudC53cml0ZVRvRW5naW5lKGVuY29kZWRQYWNrZXRzLCBwYWNrZXRPcHRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdHMgYSBwYWNrZXQgYW5kIGV4cGVjdHMgbXVsdGlwbGUgYWNrbm93bGVkZ2VtZW50cy5cbiAgICAgKlxuICAgICAqIE9wdGlvbnM6XG4gICAgICogIC0gYGZsYWdzYCB7T2JqZWN0fSBmbGFncyBmb3IgdGhpcyBwYWNrZXRcbiAgICAgKiAgLSBgZXhjZXB0YCB7QXJyYXl9IHNpZHMgdGhhdCBzaG91bGQgYmUgZXhjbHVkZWRcbiAgICAgKiAgLSBgcm9vbXNgIHtBcnJheX0gbGlzdCBvZiByb29tcyB0byBicm9hZGNhc3QgdG9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgICB0aGUgcGFja2V0IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICAgICB0aGUgb3B0aW9uc1xuICAgICAqIEBwYXJhbSBjbGllbnRDb3VudENhbGxiYWNrIC0gdGhlIG51bWJlciBvZiBjbGllbnRzIHRoYXQgcmVjZWl2ZWQgdGhlIHBhY2tldFxuICAgICAqIEBwYXJhbSBhY2sgICAgICAgICAgICAgICAgIC0gdGhlIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggY2xpZW50IHJlc3BvbnNlXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgYnJvYWRjYXN0V2l0aEFjayhwYWNrZXQsIG9wdHMsIGNsaWVudENvdW50Q2FsbGJhY2ssIGFjaykge1xuICAgICAgICBjb25zdCBmbGFncyA9IG9wdHMuZmxhZ3MgfHwge307XG4gICAgICAgIGNvbnN0IHBhY2tldE9wdHMgPSB7XG4gICAgICAgICAgICBwcmVFbmNvZGVkOiB0cnVlLFxuICAgICAgICAgICAgdm9sYXRpbGU6IGZsYWdzLnZvbGF0aWxlLFxuICAgICAgICAgICAgY29tcHJlc3M6IGZsYWdzLmNvbXByZXNzLFxuICAgICAgICB9O1xuICAgICAgICBwYWNrZXQubnNwID0gdGhpcy5uc3AubmFtZTtcbiAgICAgICAgLy8gd2UgY2FuIHVzZSB0aGUgc2FtZSBpZCBmb3IgZWFjaCBwYWNrZXQsIHNpbmNlIHRoZSBfaWRzIGNvdW50ZXIgaXMgY29tbW9uIChubyBkdXBsaWNhdGUpXG4gICAgICAgIHBhY2tldC5pZCA9IHRoaXMubnNwLl9pZHMrKztcbiAgICAgICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSB0aGlzLl9lbmNvZGUocGFja2V0LCBwYWNrZXRPcHRzKTtcbiAgICAgICAgbGV0IGNsaWVudENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAvLyB0cmFjayB0aGUgdG90YWwgbnVtYmVyIG9mIGFja25vd2xlZGdlbWVudHMgdGhhdCBhcmUgZXhwZWN0ZWRcbiAgICAgICAgICAgIGNsaWVudENvdW50Kys7XG4gICAgICAgICAgICAvLyBjYWxsIHRoZSBhY2sgY2FsbGJhY2sgZm9yIGVhY2ggY2xpZW50IHJlc3BvbnNlXG4gICAgICAgICAgICBzb2NrZXQuYWNrcy5zZXQocGFja2V0LmlkLCBhY2spO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb2NrZXQubm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHNvY2tldC5ub3RpZnlPdXRnb2luZ0xpc3RlbmVycyhwYWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ja2V0LmNsaWVudC53cml0ZVRvRW5naW5lKGVuY29kZWRQYWNrZXRzLCBwYWNrZXRPcHRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNsaWVudENvdW50Q2FsbGJhY2soY2xpZW50Q291bnQpO1xuICAgIH1cbiAgICBfZW5jb2RlKHBhY2tldCwgcGFja2V0T3B0cykge1xuICAgICAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0KTtcbiAgICAgICAgaWYgKGNhblByZUNvbXB1dGVGcmFtZSAmJlxuICAgICAgICAgICAgZW5jb2RlZFBhY2tldHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICB0eXBlb2YgZW5jb2RlZFBhY2tldHNbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIFwiNFwiIGJlaW5nIHRoZSBcIm1lc3NhZ2VcIiBwYWNrZXQgdHlwZSBpbiB0aGUgRW5naW5lLklPIHByb3RvY29sXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmZyb20oXCI0XCIgKyBlbmNvZGVkUGFja2V0c1swXSk7XG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzYxNyNpc3N1ZWNvbW1lbnQtMjgzMDAyNDY5XG4gICAgICAgICAgICBwYWNrZXRPcHRzLndzUHJlRW5jb2RlZEZyYW1lID0gV2ViU29ja2V0LlNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgICAgICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1hc2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJzdjE6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG9wY29kZTogMSxcbiAgICAgICAgICAgICAgICBmaW46IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlZFBhY2tldHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIHNvY2tldHMgYnkgc2lkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZXQ8Um9vbT59IHJvb21zICAgdGhlIGV4cGxpY2l0IHNldCBvZiByb29tcyB0byBjaGVjay5cbiAgICAgKi9cbiAgICBzb2NrZXRzKHJvb21zKSB7XG4gICAgICAgIGNvbnN0IHNpZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuYXBwbHkoeyByb29tcyB9LCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICBzaWRzLmFkZChzb2NrZXQuaWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzaWRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGlzdCBvZiByb29tcyBhIGdpdmVuIHNvY2tldCBoYXMgam9pbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTb2NrZXRJZH0gaWQgICB0aGUgc29ja2V0IGlkXG4gICAgICovXG4gICAgc29ja2V0Um9vbXMoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lkcy5nZXQoaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIHRoZSBmaWx0ZXJzIHRvIGFwcGx5XG4gICAgICovXG4gICAgZmV0Y2hTb2NrZXRzKG9wdHMpIHtcbiAgICAgICAgY29uc3Qgc29ja2V0cyA9IFtdO1xuICAgICAgICB0aGlzLmFwcGx5KG9wdHMsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIHNvY2tldHMucHVzaChzb2NrZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzb2NrZXRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgam9pbiB0aGUgc3BlY2lmaWVkIHJvb21zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIHRoZSBmaWx0ZXJzIHRvIGFwcGx5XG4gICAgICogQHBhcmFtIHJvb21zIC0gdGhlIHJvb21zIHRvIGpvaW5cbiAgICAgKi9cbiAgICBhZGRTb2NrZXRzKG9wdHMsIHJvb21zKSB7XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgc29ja2V0LmpvaW4ocm9vbXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIHNwZWNpZmllZCByb29tc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSB0aGUgZmlsdGVycyB0byBhcHBseVxuICAgICAqIEBwYXJhbSByb29tcyAtIHRoZSByb29tcyB0byBsZWF2ZVxuICAgICAqL1xuICAgIGRlbFNvY2tldHMob3B0cywgcm9vbXMpIHtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICByb29tcy5mb3JFYWNoKChyb29tKSA9PiBzb2NrZXQubGVhdmUocm9vbSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSB0aGUgZmlsdGVycyB0byBhcHBseVxuICAgICAqIEBwYXJhbSBjbG9zZSAtIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RTb2NrZXRzKG9wdHMsIGNsb3NlKSB7XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoY2xvc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXBwbHkob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgcm9vbXMgPSBvcHRzLnJvb21zO1xuICAgICAgICBjb25zdCBleGNlcHQgPSB0aGlzLmNvbXB1dGVFeGNlcHRTaWRzKG9wdHMuZXhjZXB0KTtcbiAgICAgICAgaWYgKHJvb21zLnNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgcm9vbSBvZiByb29tcykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yb29tcy5oYXMocm9vbSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaWQgb2YgdGhpcy5yb29tcy5nZXQocm9vbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkcy5oYXMoaWQpIHx8IGV4Y2VwdC5oYXMoaWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubnNwLnNvY2tldHMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soc29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkcy5hZGQoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaWRdIG9mIHRoaXMuc2lkcykge1xuICAgICAgICAgICAgICAgIGlmIChleGNlcHQuaGFzKGlkKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uc3Auc29ja2V0cy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChzb2NrZXQpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHNvY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZUV4Y2VwdFNpZHMoZXhjZXB0Um9vbXMpIHtcbiAgICAgICAgY29uc3QgZXhjZXB0U2lkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKGV4Y2VwdFJvb21zICYmIGV4Y2VwdFJvb21zLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJvb20gb2YgZXhjZXB0Um9vbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yb29tcy5oYXMocm9vbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb29tcy5nZXQocm9vbSkuZm9yRWFjaCgoc2lkKSA9PiBleGNlcHRTaWRzLmFkZChzaWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4Y2VwdFNpZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBwYWNrZXQgdG8gdGhlIG90aGVyIFNvY2tldC5JTyBzZXJ2ZXJzIGluIHRoZSBjbHVzdGVyXG4gICAgICogQHBhcmFtIHBhY2tldCAtIGFuIGFycmF5IG9mIGFyZ3VtZW50cywgd2hpY2ggbWF5IGluY2x1ZGUgYW4gYWNrbm93bGVkZ2VtZW50IGNhbGxiYWNrIGF0IHRoZSBlbmRcbiAgICAgKi9cbiAgICBzZXJ2ZXJTaWRlRW1pdChwYWNrZXQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwidGhpcyBhZGFwdGVyIGRvZXMgbm90IHN1cHBvcnQgdGhlIHNlcnZlclNpZGVFbWl0KCkgZnVuY3Rpb25hbGl0eVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2F2ZSB0aGUgY2xpZW50IHNlc3Npb24gaW4gb3JkZXIgdG8gcmVzdG9yZSBpdCB1cG9uIHJlY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBwZXJzaXN0U2Vzc2lvbihzZXNzaW9uKSB7IH1cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIHRoZSBzZXNzaW9uIGFuZCBmaW5kIHRoZSBwYWNrZXRzIHRoYXQgd2VyZSBtaXNzZWQgYnkgdGhlIGNsaWVudC5cbiAgICAgKiBAcGFyYW0gcGlkXG4gICAgICogQHBhcmFtIG9mZnNldFxuICAgICAqL1xuICAgIHJlc3RvcmVTZXNzaW9uKHBpZCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuQWRhcHRlciA9IEFkYXB0ZXI7XG5jbGFzcyBTZXNzaW9uQXdhcmVBZGFwdGVyIGV4dGVuZHMgQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IobnNwKSB7XG4gICAgICAgIHN1cGVyKG5zcCk7XG4gICAgICAgIHRoaXMubnNwID0gbnNwO1xuICAgICAgICB0aGlzLnNlc3Npb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnBhY2tldHMgPSBbXTtcbiAgICAgICAgdGhpcy5tYXhEaXNjb25uZWN0aW9uRHVyYXRpb24gPVxuICAgICAgICAgICAgbnNwLnNlcnZlci5vcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5Lm1heERpc2Nvbm5lY3Rpb25EdXJhdGlvbjtcbiAgICAgICAgY29uc3QgdGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGQgPSBEYXRlLm5vdygpIC0gdGhpcy5tYXhEaXNjb25uZWN0aW9uRHVyYXRpb247XG4gICAgICAgICAgICB0aGlzLnNlc3Npb25zLmZvckVhY2goKHNlc3Npb24sIHNlc3Npb25JZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0V4cGlyZWQgPSBzZXNzaW9uLmRpc2Nvbm5lY3RlZEF0IDwgdGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIGlmIChoYXNFeHBpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbnMuZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5wYWNrZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRXhwaXJlZCA9IHRoaXMucGFja2V0c1tpXS5lbWl0dGVkQXQgPCB0aHJlc2hvbGQ7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0V4cGlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWNrZXRzLnNwbGljZSgwLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgNjAgKiAxMDAwKTtcbiAgICAgICAgLy8gcHJldmVudHMgdGhlIHRpbWVyIGZyb20ga2VlcGluZyB0aGUgcHJvY2VzcyBhbGl2ZVxuICAgICAgICB0aW1lci51bnJlZigpO1xuICAgIH1cbiAgICBwZXJzaXN0U2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgICAgIHNlc3Npb24uZGlzY29ubmVjdGVkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnNlc3Npb25zLnNldChzZXNzaW9uLnBpZCwgc2Vzc2lvbik7XG4gICAgfVxuICAgIHJlc3RvcmVTZXNzaW9uKHBpZCwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLnNlc3Npb25zLmdldChwaWQpO1xuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgIC8vIHRoZSBzZXNzaW9uIG1heSBoYXZlIGV4cGlyZWRcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc0V4cGlyZWQgPSBzZXNzaW9uLmRpc2Nvbm5lY3RlZEF0ICsgdGhpcy5tYXhEaXNjb25uZWN0aW9uRHVyYXRpb24gPCBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgLy8gdGhlIHNlc3Npb24gaGFzIGV4cGlyZWRcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbnMuZGVsZXRlKHBpZCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucGFja2V0cy5maW5kSW5kZXgoKHBhY2tldCkgPT4gcGFja2V0LmlkID09PSBvZmZzZXQpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyB0aGUgb2Zmc2V0IG1heSBiZSB0b28gb2xkXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaXNzZWRQYWNrZXRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIDE7IGkgPCB0aGlzLnBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IHRoaXMucGFja2V0c1tpXTtcbiAgICAgICAgICAgIGlmIChzaG91bGRJbmNsdWRlUGFja2V0KHNlc3Npb24ucm9vbXMsIHBhY2tldC5vcHRzKSkge1xuICAgICAgICAgICAgICAgIG1pc3NlZFBhY2tldHMucHVzaChwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlc3Npb24pLCB7IG1pc3NlZFBhY2tldHMgfSkpO1xuICAgIH1cbiAgICBicm9hZGNhc3QocGFja2V0LCBvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgaXNFdmVudFBhY2tldCA9IHBhY2tldC50eXBlID09PSAyO1xuICAgICAgICAvLyBwYWNrZXRzIHdpdGggYWNrbm93bGVkZ2VtZW50IGFyZSBub3Qgc3RvcmVkIGJlY2F1c2UgdGhlIGFja25vd2xlZGdlbWVudCBmdW5jdGlvbiBjYW5ub3QgYmUgc2VyaWFsaXplZCBhbmRcbiAgICAgICAgLy8gcmVzdG9yZWQgb24gYW5vdGhlciBzZXJ2ZXIgdXBvbiByZWNvbm5lY3Rpb25cbiAgICAgICAgY29uc3Qgd2l0aG91dEFja25vd2xlZGdlbWVudCA9IHBhY2tldC5pZCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBub3RWb2xhdGlsZSA9ICgoX2EgPSBvcHRzLmZsYWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eudm9sYXRpbGUpID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpc0V2ZW50UGFja2V0ICYmIHdpdGhvdXRBY2tub3dsZWRnZW1lbnQgJiYgbm90Vm9sYXRpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gKDAsIHllYXN0XzEueWVhc3QpKCk7XG4gICAgICAgICAgICAvLyB0aGUgb2Zmc2V0IGlzIHN0b3JlZCBhdCB0aGUgZW5kIG9mIHRoZSBkYXRhIGFycmF5LCBzbyB0aGUgY2xpZW50IGtub3dzIHRoZSBJRCBvZiB0aGUgbGFzdCBwYWNrZXQgaXQgaGFzXG4gICAgICAgICAgICAvLyBwcm9jZXNzZWQgKGFuZCB0aGUgZm9ybWF0IGlzIGJhY2t3YXJkLWNvbXBhdGlibGUpXG4gICAgICAgICAgICBwYWNrZXQuZGF0YS5wdXNoKGlkKTtcbiAgICAgICAgICAgIHRoaXMucGFja2V0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgICAgIGRhdGE6IHBhY2tldC5kYXRhLFxuICAgICAgICAgICAgICAgIGVtaXR0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmJyb2FkY2FzdChwYWNrZXQsIG9wdHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2Vzc2lvbkF3YXJlQWRhcHRlciA9IFNlc3Npb25Bd2FyZUFkYXB0ZXI7XG5mdW5jdGlvbiBzaG91bGRJbmNsdWRlUGFja2V0KHNlc3Npb25Sb29tcywgb3B0cykge1xuICAgIGNvbnN0IGluY2x1ZGVkID0gb3B0cy5yb29tcy5zaXplID09PSAwIHx8IHNlc3Npb25Sb29tcy5zb21lKChyb29tKSA9PiBvcHRzLnJvb21zLmhhcyhyb29tKSk7XG4gICAgY29uc3Qgbm90RXhjbHVkZWQgPSBzZXNzaW9uUm9vbXMuZXZlcnkoKHJvb20pID0+ICFvcHRzLmV4Y2VwdC5oYXMocm9vbSkpO1xuICAgIHJldHVybiBpbmNsdWRlZCAmJiBub3RFeGNsdWRlZDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/dist/in-memory-adapter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MessageType = exports.ClusterAdapterWithHeartbeat = exports.ClusterAdapter = exports.SessionAwareAdapter = exports.Adapter = void 0;\nvar in_memory_adapter_1 = __webpack_require__(/*! ./in-memory-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/in-memory-adapter.js\");\nObject.defineProperty(exports, \"Adapter\", ({ enumerable: true, get: function () { return in_memory_adapter_1.Adapter; } }));\nObject.defineProperty(exports, \"SessionAwareAdapter\", ({ enumerable: true, get: function () { return in_memory_adapter_1.SessionAwareAdapter; } }));\nvar cluster_adapter_1 = __webpack_require__(/*! ./cluster-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/cluster-adapter.js\");\nObject.defineProperty(exports, \"ClusterAdapter\", ({ enumerable: true, get: function () { return cluster_adapter_1.ClusterAdapter; } }));\nObject.defineProperty(exports, \"ClusterAdapterWithHeartbeat\", ({ enumerable: true, get: function () { return cluster_adapter_1.ClusterAdapterWithHeartbeat; } }));\nObject.defineProperty(exports, \"MessageType\", ({ enumerable: true, get: function () { return cluster_adapter_1.MessageType; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxtQ0FBbUMsR0FBRyxzQkFBc0IsR0FBRywyQkFBMkIsR0FBRyxlQUFlO0FBQ2xJLDBCQUEwQixtQkFBTyxDQUFDLDZGQUFxQjtBQUN2RCwyQ0FBMEMsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDekgsdURBQXNELEVBQUUscUNBQXFDLG1EQUFtRCxFQUFDO0FBQ2pKLHdCQUF3QixtQkFBTyxDQUFDLHlGQUFtQjtBQUNuRCxrREFBaUQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDckksK0RBQThELEVBQUUscUNBQXFDLHlEQUF5RCxFQUFDO0FBQy9KLCtDQUE4QyxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQyIsInNvdXJjZXMiOlsiL1ZvbHVtZXMvU29ubmFMYWJzL0hldGljL2RhdGEtdGVjaC1uZXh0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tYWRhcHRlci9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXNzYWdlVHlwZSA9IGV4cG9ydHMuQ2x1c3RlckFkYXB0ZXJXaXRoSGVhcnRiZWF0ID0gZXhwb3J0cy5DbHVzdGVyQWRhcHRlciA9IGV4cG9ydHMuU2Vzc2lvbkF3YXJlQWRhcHRlciA9IGV4cG9ydHMuQWRhcHRlciA9IHZvaWQgMDtcbnZhciBpbl9tZW1vcnlfYWRhcHRlcl8xID0gcmVxdWlyZShcIi4vaW4tbWVtb3J5LWFkYXB0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBZGFwdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbl9tZW1vcnlfYWRhcHRlcl8xLkFkYXB0ZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXNzaW9uQXdhcmVBZGFwdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbl9tZW1vcnlfYWRhcHRlcl8xLlNlc3Npb25Bd2FyZUFkYXB0ZXI7IH0gfSk7XG52YXIgY2x1c3Rlcl9hZGFwdGVyXzEgPSByZXF1aXJlKFwiLi9jbHVzdGVyLWFkYXB0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbHVzdGVyQWRhcHRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2x1c3Rlcl9hZGFwdGVyXzEuQ2x1c3RlckFkYXB0ZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbHVzdGVyQWRhcHRlcldpdGhIZWFydGJlYXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsdXN0ZXJfYWRhcHRlcl8xLkNsdXN0ZXJBZGFwdGVyV2l0aEhlYXJ0YmVhdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbHVzdGVyX2FkYXB0ZXJfMS5NZXNzYWdlVHlwZTsgfSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/dist/index.js\n");

/***/ })

};
;